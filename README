dmalloc library - version 1.0

INTRODUCTION
LD_PRELOAD and SYMBOL FISHING
OUTPUT
NOTES
PROBLEMS
TODO

==================================================================
INTRODUCTION

This is a malloc/calloc/realloc/free debug libary (located in 'src')
and an associated test program (located in 'test'). To see the test
code in action then from the terminal and inside the dmalloc directory
type:

      make check


A variety of debug information will be printed on stderr every five
seconds or thereabouts. More on output format in OUTPUT

==================================================================
LD_PRELOAD and SYMBOL FISHING

LD_PRELOAD gives you a method for having your executable find an
alternative version of a library routine 'before' the normal
version. This causes the program to call your version of malloc() for
instance. In order to call through to the original malloc() then you
need to fish out the symbol for the original malloc(). An invocation
with LD_PRELOAD is shown below.

LD_PRELOAD=$PWD/src/libdmalloc.so ./hello_world

To read more about this technique read through the presentation from
Peter Goldsborough at the following link.

To see how preload and symbol fishing are accomplished under MAC OSX
have a look at the 'check' target in test/Makefile and the source code
for the library under 'src'


==================================================================
NOTES

Current allocations by age: ( # = 8,123 current allocations)

The above is one of the suggested stat output lines. At first I was
convinced that I would need to keep a list of all allocated pointers
and the time they were allocated so that I could compute the age
buckets. This seemed like a daunting task (space, time, and
complexity).

It would be great if we could just keep the counts in the buckets and
graduate counts from one bucket to the next as time goes on. This also
poses the problem of how to decrement the buckets. I think the
decrement could be solved by allocating an extra time_t sized struct
in each alloc such that on free, I could check that time and decrement
the correct time bucket.

The problem is figuring out how to move counts from one bucket to the
next. For example, consider the less than one second bucket. Assuming
that it has a count of ten. When the code tries to graduate items from
one bucket to the next how does it know if an item has been in there
for a tenth of a second or two seconds. It is just a count which loses
the granularity of each particular item.

Basically we are watching up 1000 seconds, anything more than that is
one bucket (the > 1000 bucket). If we break that 1000 seconds up into
1000 slices that is 1s per slice. When a new alloc or free comes in
then we check if it has been more than one second since the last
update. If it has then we can round the time to the nearest 1s and
march the list adjusting each bucket accordingly and then add our new
item (assuming it was an alloc) to the first slice. We can track any
accumulated error from the rounding and play that back into the nest
time.

There is a 100ms inaccuracy introduces immediately because items in
that first slice may have been added anywhere in a 1s window and may
be promoted early. But each subsequent bucket basically has all items
aligned at the same point in time. The other source of error is the
caused by the rounding. This can be accumulated and be added to the
next time and thus carried forward and minimized.

The final problem comes on the free(). We can store the time of the
allocation in some extra memory stored in the allocation iteself. The
problem then is reduced to determining accurately which slice needs to
be decremented. We can compute which bucket it should be in but it may
have been promoted and not be where we expect it (although it should
be close). Close is actually good enough. If for instance, we believe
the correct slice on a free() is slot 547 then does it really matter
if the slice is really 546 or 548. Given the algorithm I am talking
about it should be in on of those three.

Algorithm becomes:

new element arrives or free or time to log
note time
// advance slices by time + accumulated error
if (last update > 1s) then
   for (i=999; i>=0; i++)
       slice[i+whole seconds] = slice[i]
   endfor
endif
if alloc then increment slice[0]
if freeO then decrement slice[x]
do log if needed

==================================================================
PROBLEMS

Tracking total allocated bytes can be very tricky as many short lived
programs do not free() allocated memory and instead run to completion
and count on the OS to simply free any allocated heap areas. Thus a
simple Hello World program can easily show many mallocs without
associated frees as demonstrated in the following output.

DYLD_INSERT_LIBRARIES=../src/libdmalloc.dylib DYLD_FORCE_FLAT_NAMESPACE=1 ./hello_world
malloc(23949,0x110734dc0) malloc: my_malloc: 0x7fd7de808200 = malloc(1536)
malloc(23949,0x110734dc0) malloc: my_malloc: 0x7fd7de5040f0 = malloc(32)
malloc(23949,0x110734dc0) malloc: my_free: free(0x7fd7de504110)
malloc(23949,0x110734dc0) malloc: my_free: free(0x7fd7de5040e0)
malloc(23949,0x110734dc0) malloc: my_free: free(0x7fd7de504130)
malloc(23949,0x110734dc0) malloc: my_malloc: 0x7fd7de504130 = malloc(32)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de5043c0 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de5043e0 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504400 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504420 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504440 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504460 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504480 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de5044a0 = calloc(32 1)
.... it goes on for sometime with very few free() calls.

==================================================================
TODO

	* realloc() - Currently realloc() statistics gathers treats a
          realloc as a free followed by an alloc. This loses precision
          on the lifetime of the allocation. A better implementation
          might notice that the base pointer has not changed and
          simnply update the total bytes allocated as a result.


