dmalloc library - see ChangeLog for version info

INTRODUCTION
LD_PRELOAD and SYMBOL FISHING
API
OUTPUT
NOTES
PROBLEMS
TODO

==================================================================
INTRODUCTION

This is a malloc/calloc/realloc/free debug libary (located in 'src')
and an associated test program (located in 'test'). To see the test
code in action then from the terminal and inside the dmalloc directory
type:

      make check


A variety of debug information will be printed on stderr every five
seconds or thereabouts. More on output format in OUTPUT

It is not necessary to recompile your application to use this library
as it intercepts malloc type routines (see LD_PRELOAD below). There is
a control API if you desire to explicitly link against the library and
control aspects of its operation (see API below)

==================================================================
LD_PRELOAD and SYMBOL FISHING

LD_PRELOAD gives you a method for having your executable find an
alternative version of a library routine 'before' the normal
version. This causes the program to call your version of malloc() for
instance. In order to call through to the original malloc() then you
need to fish out the symbol for the original malloc(). An invocation
with LD_PRELOAD is shown below.

LD_PRELOAD=$PWD/src/libdmalloc.so ./hello_world

To read more about this technique read through the presentation from
Peter Goldsborough at the following link.

To see how preload and symbol fishing are accomplished under MAC OSX
have a look at the 'check' target in test/Makefile and the source code
for the library under 'src'

==================================================================
API

TBD


==================================================================
NOTES

Current allocations by age: ( # = 8,123 current allocations)
< 1 sec: ###
< 10 sec: ##
< 100 sec: ##
< 1000 sec: ######################### > 1000 sec:


The above is one of the stat output lines. At first I was convinced
that I would need to keep a list of all allocated pointers and the
time they were allocated so that I could compute the age buckets. This
seemed like a daunting task (space, time, and complexity).

Fortunately, there is an easier way. Keeping an array of 1000 entries
is sufficient. Each "bucket" holds the count of allocations sharing
that birthday. For instance, a count of 3 at index 4 (the 5th
position) indicates we have 3 allocations that have persisted for five
seconds. We update the list opportunistically and only if the elapsed
time since the last update is more than one second.

There is a loss of accuracy in the first bucket. We don't know how
long an allocation has really existed during that first second. It may
have enetered that bucket only a few milliseconds before a one second
boundary and then finds itself quickly promoted to the next
bucket. For subsequent time slots all promotions are accurate,
i.e. more errors don't accumulate.

We hide some birthday magic in extra bytes in the header of each
allocation so that on free() we can decrement the count in the correct
bucket.

We do incur the cost of traversing a 1000 element list of integers to
do the update so this should be undertaken only as needed but is not
hugely expensive.

Algorithm becomes basically;

alloc()
	new allocation
	note birthday
	update current list if last update more than one second ago
	increment time 0 bucket

free()
	extract birthday
	free allocation
	decrement count at computed bucket


==================================================================
PROBLEMS

Tracking total allocated bytes can be very tricky as many short lived
programs do not free() allocated memory and instead run to completion
and count on the OS to simply free any allocated heap areas. Thus a
simple Hello World program can easily show many mallocs without
associated frees as demonstrated in the following output.

DYLD_INSERT_LIBRARIES=../src/libdmalloc.dylib DYLD_FORCE_FLAT_NAMESPACE=1 ./hello_world
malloc(23949,0x110734dc0) malloc: my_malloc: 0x7fd7de808200 = malloc(1536)
malloc(23949,0x110734dc0) malloc: my_malloc: 0x7fd7de5040f0 = malloc(32)
malloc(23949,0x110734dc0) malloc: my_free: free(0x7fd7de504110)
malloc(23949,0x110734dc0) malloc: my_free: free(0x7fd7de5040e0)
malloc(23949,0x110734dc0) malloc: my_free: free(0x7fd7de504130)
malloc(23949,0x110734dc0) malloc: my_malloc: 0x7fd7de504130 = malloc(32)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de5043c0 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de5043e0 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504400 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504420 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504440 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504460 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de504480 = calloc(32 1)
malloc(23949,0x110734dc0) malloc: my_calloc: 0x7fd7de5044a0 = calloc(32 1)
.... it goes on for sometime with very few free() calls.

==================================================================
TODO

	* realloc() - Currently realloc() statistics gathers treats a
	  realloc as a free followed by an alloc. This loses precision
	  on the lifetime of the allocation. A better implementation
	  might notice that the base pointer has not changed and
	  simnply update the total bytes allocated as a result.


